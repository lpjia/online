<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <!-- 文档标题-->
  <title>css笔记</title>
  <meta name="keywords" content="">
  <meta name="description" content="">
  <!-- theme1用引号包着也能被正确替换 -->
  <link rel="stylesheet" href="../html-component/theme1.css">
</head>

<body>
  <style>
    body {
      padding: 0 10px;
    }
  </style>
  <!-- 插入主题样式 -->
  <!-- <style>
    theme1
  </style> -->
  <!-- 插入marked转换后的html -->
  <div class="markdown-body"><h1 id="元素-标签">元素 标签</h1>
<h2 id="pre">pre</h2>
<p>预格式化文本元素</p>
<p>空白折叠: 在源代码中的连续空白字符(空格、换行、制表-tab键), 在页面显示时, 会被折叠为一个空格</p>
<p>例外: 在pre元素中的内容不会出现空白折叠</p>
<p>在pre元素内部出现的内容, 会按照源代码格式显示到页面上</p>
<p>该元素通常用于在网页中显示一些代码。</p>
<p>pre元素功能的本质: 它有一个默认的css属性, white-space: pre;</p>
<blockquote>
<p>显示代码时, 通常外面套code元素, code表示代码区域</p>
</blockquote>
<h2 id="span【无语义】">span【无语义】</h2>
<p>没有语义, 仅用于设置样式</p>
<blockquote>
<p>以前: 某些元素在显示时会独占一行(块级元素), 而某些元素不会(行级元素)。
到了HTML5, 已经弃用这种说法了(根据W3C官网的描述)</p>
</blockquote>
<h2 id="href属性">href属性</h2>
<p>hyper reference: 通常表示跳转地址</p>
<ol>
<li>普通链接</li>
<li>锚链接</li>
</ol>
<p>id属性: 全局属性, 表示元素在文档中的唯一编号</p>
<ol start="3">
<li>功能链接</li>
</ol>
<p>点击后, 触发某个功能</p>
<ul>
<li>执行JS代码, javascript:</li>
<li>发送邮件, mailto:
要求用户计算机上安装有邮件发送软件: exchange</li>
<li>拨号, tel:
要求用户计算机上安装有拨号软件, 或使用的是移动端访问</li>
</ul>
<h2 id="target属性">target属性</h2>
<p>表示跳转窗口位置。</p>
<p>target的取值:</p>
<ul>
<li>_self: 在当前页面窗口中打开, 默认值</li>
<li>_blank: 在新窗口中打开</li>
</ul>
<h1 id="路径的书写">路径的书写</h1>
<h2 id="站内资源和站外资源">站内资源和站外资源</h2>
<p>站内资源: 当前网站的资源</p>
<p>站外资源: 非当前网站的资源</p>
<h2 id="绝对路径和相对路径">绝对路径和相对路径</h2>
<p>站外资源: 绝对路径</p>
<p>站内资源: 相对路径</p>
<ol>
<li>绝对路径</li>
</ol>
<p>绝对路径的书写格式</p>
<p>url地址:</p>
<pre><code>协议名://主机号:端口号/路径

schema://host:port/path
</code></pre>
<p>协议名: http、https、file</p>
<p>主机号: 域名、IP地址</p>
<p>端口号: 如果协议是http协议, 默认端口号为80; 如果协议是https协议, 默认端口号为443;</p>
<p>当跳转目标和当前页面的协议相同时, 可以省略协议</p>
<ol start="2">
<li>相对路径</li>
</ol>
<p>以./开头, ./表示当前资源所在的目录</p>
<p>可以书写../表示返回上一级目录</p>
<h1 id="常见样式声明">常见样式声明</h1>
<ol>
<li>color</li>
</ol>
<p>元素内部的文字颜色</p>
<p><strong>预设值</strong>: 定义好的单词</p>
<p><strong>三原色, 色值</strong>: 光学三原色(红、绿、蓝), 每个颜色可以使用0-255之间的数字来表达, 色值</p>
<p>16进制也就是两位, 可以表示0-255</p>
<pre><code>rgb表示法:
rgb(0, 255, 0)
hex(16进制)表示法:
#红绿蓝
</code></pre>
<ol start="2">
<li>background-color</li>
</ol>
<p>元素背景颜色</p>
<ol start="3">
<li>font-size</li>
</ol>
<p>元素内部文字的尺寸大小</p>
<p>1)px: 像素, 绝对单位, 简单的理解为文字的宽高占多少个像素
2)em: 相对单位, 相对于父元素的字体大小</p>
<p>每个元素必须有字体大小, 如果没有声明, 则直接使用父元素的字体大小, 如果没有父元素(html元素没有父元素, body元素的父元素是html元素), 则使用基准字号(浏览器里设置的字号大小)。</p>
<blockquote>
<p>user agent, UA, 用户代理(浏览器)</p>
</blockquote>
<ol start="4">
<li>font-weight</li>
</ol>
<p>文字粗细程度, 可以取值为数字, 可以取值为预设值</p>
<ol start="5">
<li>font-family</li>
</ol>
<p>必须用户计算机中存在的字体才有效。</p>
<p>使用多个字体, 以匹配不同环境</p>
<blockquote>
<p>font-family: 字体1,字体2,字体3,sans-serif;</p>
</blockquote>
<p>匹配规则: 优先匹配前面字体, 没有才匹配后面字体</p>
<p>sans-serif, 非衬线字体, 意思是如果前面的字体都没有, 让计算机环境自行选择一个非衬线字体, 一般都有默认的非衬线字体</p>
<ol start="6">
<li>line-height</li>
</ol>
<p>每行文本的高度, 值越大, 每行的间距越大</p>
<p>设置行高为容器的高度, 可以让单行文本垂直居中</p>
<p>行高可以设置为纯数字, 表示相对于当前元素的字体大小</p>
<h1 id="选择器">选择器</h1>
<p>选择器: 帮助你精准的选中想要的元素</p>
<h2 id="简单选择器">简单选择器</h2>
<ol>
<li>ID选择器</li>
</ol>
<p>#开头, 一般不重复
实测发现有多个相同id时, 也能选中多个</p>
<ol start="2">
<li>元素选择器</li>
</ol>
<p>span、div等, 表示选中所有该元素</p>
<ol start="3">
<li>类选择器</li>
</ol>
<p>.开头, 表示选中所有该class</p>
<ol start="4">
<li>通配符选择器</li>
</ol>
<p>*, 表示选中所有元素</p>
<ol start="5">
<li>属性选择器</li>
</ol>
<p>[属性名=属性值]
如[name]、[href]、[data-id=&quot;zdy&quot;]、[class=&quot;myclass&quot;]、[attr^=value]等
带有属性名或属性值为某值的属性</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Attribute_selectors">有很多, 具体规则看MDN</a></p>
<ol start="6">
<li>伪类选择器</li>
</ol>
<p>选中某些元素的某种状态</p>
<ol>
<li>:link 超链接未访问时的状态</li>
<li>:visited 超链接访问过后的状态</li>
<li>:hover 鼠标悬停状态</li>
<li>:active 激活状态, 鼠标按下状态</li>
</ol>
<p>巧记: 爱恨原则</p>
<ol start="7">
<li>伪元素选择器</li>
</ol>
<p>生成并选中某个元素内部的第一个子元素或最后一个子元素
::before
::after
这两个伪元素都是行盒</p>
<h2 id="选择器的组合">选择器的组合</h2>
<ol>
<li>并且 紧邻着 比如div.cls</li>
<li>后代元素 空格</li>
<li>子元素 &gt;</li>
<li>相邻兄弟元素 +</li>
<li>兄弟元素 ~</li>
</ol>
<h2 id="选择器的并列">选择器的并列</h2>
<p>多个选择器, 用逗号分隔</p>
<p>语法糖</p>
<h2 id="css代码书写位置">CSS代码书写位置</h2>
<ol>
<li>内部样式表</li>
</ol>
<p>书写在style元素中</p>
<ol start="2">
<li>内联样式表 元素样式表</li>
</ol>
<p>直接书写在元素的style属性</p>
<ol start="3">
<li>外部样式表</li>
</ol>
<p>将样式书写到独立的css文件</p>
<h1 id="继承">继承</h1>
<p>子元素会继承父元素的某些CSS属性</p>
<p>通常, 跟文字内容相关的属性都能被继承</p>
<p>所以给body元素设置一个共用的字体, 所有的子元素(子元素的子元素)都会继承</p>
<h1 id="层叠">层叠</h1>
<p>层叠: 解决声明冲突的过程, 浏览器自动处理</p>
<h2 id="1-比较重要性">1. 比较重要性</h2>
<h2 id="2-比较特殊性">2. 比较特殊性</h2>
<h2 id="3-比较源次序">3. 比较源次序</h2>
<h2 id="应用">应用</h2>
<ol>
<li>重置样式表</li>
</ol>
<p>书写一些作者样式, 覆盖浏览器的默认样式</p>
<p>重置样式表 -&gt; 浏览器的默认样式</p>
<p>常见的重置样式表: normalize.css、reset.css、meyer.css</p>
<h1 id="盒模型">盒模型</h1>
<p>box: 盒子, 每个元素在页面中都会生成一个矩形区域(盒子)</p>
<p>盒子模型:</p>
<ol>
<li>行盒, display等于inline的元素</li>
<li>块盒, display等于block的元素</li>
</ol>
<p>行盒在页面中不换行, 块盒独占一行</p>
<p>display默认值为inline</p>
<p>浏览器默认样式表设置的块盒: 容器元素、h1-6、p</p>
<p>常见的行盒: span、a、img、video、audio</p>
<h2 id="盒子的组成部分">盒子的组成部分</h2>
<p>无论是行盒还是块盒, 都由下面几个部分组成, 从内到外分别是:</p>
<ol>
<li>内容 content</li>
</ol>
<p>width、height, 设置的是盒子内容的宽高</p>
<p>内容部分通常叫做整个盒子的<strong>内容盒 content-box</strong></p>
<ol start="2">
<li>填充 padding</li>
</ol>
<p>盒子边框到盒子内容的距离</p>
<p>padding-left、padding-right、padding-top、padding-bottom</p>
<p>padding: 速写属性</p>
<p>padding: 上 右 下 左</p>
<p>填充区 + 内容区 = <strong>填充盒 padding-box</strong></p>
<ol start="3">
<li>边框 border</li>
</ol>
<p>边框 = 边框样式 + 边框宽度 + 边框颜色</p>
<p>边框样式: border-style
边框宽度: border-width
边框颜色: border-color</p>
<blockquote>
<p>默认是字体的颜色</p>
</blockquote>
<p>border: 速写属性</p>
<p>边框 + 填充区 + 内容区 = <strong>边框盒 border-box</strong></p>
<ol start="4">
<li>外边距 margin</li>
</ol>
<p>边框到其他盒子的距离</p>
<p>margin: 速写属性</p>
<h1 id="盒模型应用">盒模型应用</h1>
<h2 id="改变宽高范围">改变宽高范围</h2>
<p>默认情况下, width和height设置的是内容盒宽高</p>
<blockquote>
<p>页面重构师: 将psd文件(设计稿)制作为静态页面</p>
</blockquote>
<p>衡量设计稿尺寸的时候, 往往使用的是边框盒, 但设置width和height, 则设置的是内容盒</p>
<ol>
<li>精确计算</li>
<li>CSS3: box-sizing (content-box 默认; border-box)</li>
</ol>
<h2 id="改变背景覆盖范围">改变背景覆盖范围</h2>
<p>默认情况下, 背景覆盖边框盒</p>
<p>可以通过background-clip进行修改
border-box 默认;
padding-box
content-box</p>
<h2 id="溢出处理">溢出处理</h2>
<p>overflow, 控制内容溢出边框盒后的处理方式
宽高固定, 才会溢出
visible 可见的 默认;
hidden
scroll
auto</p>
<h2 id="断词规则">断词规则</h2>
<p>word-break, 会影响文字在什么位置被截断换行</p>
<p>normal, 普通 默认。CJK(Chinese Japan Korea)字符(文字位置截断), 非CJK字符(单词位置截断)</p>
<p>break-all, 截断所有, 所有字符都在文字处截断</p>
<p>keep-all, 保持所有, 所有文字都在单词之间截断</p>
<p>一般用默认行为, 符合人类现实世界, 不要轻易改动</p>
<h2 id="空白处理">空白处理</h2>
<p>white-space, 空白字符怎么处理
normal, 普通 默认
nowrap, 不换行
pre, 不会空白折叠</p>
<h1 id="行盒的盒模型">行盒的盒模型</h1>
<p>常见的行盒: 包含具体内容的元素</p>
<p>span、strong、em、i、img、video、audio</p>
<h2 id="显著特点">显著特点</h2>
<ol>
<li>盒子沿着内容延伸, 大多是文本内容</li>
<li>行盒不能设置宽高</li>
</ol>
<p>调整行盒的宽高, 应该使用字体大小、行高、字体类型, 间接调整。</p>
<ol start="3">
<li>填充区</li>
</ol>
<p>水平方向有效, 垂直方向仅会影响背景, 不会实际占据空间。</p>
<ol start="4">
<li>边框</li>
</ol>
<p>水平方向有效, 垂直方向不会实际占据空间。</p>
<ol start="5">
<li>外边距</li>
</ol>
<p>水平方向有效, 垂直方向不会实际占据空间。</p>
<h2 id="行块盒">行块盒</h2>
<p>display: inline-block的盒子</p>
<ol>
<li>不独占一行</li>
<li>盒模型中所有尺寸都有效</li>
</ol>
<h2 id="空白折叠">空白折叠</h2>
<p>空白折叠, 发生在行盒(行块盒)内部或行盒之间</p>
<h2 id="可替换元素-和-非可替换元素">可替换元素 和 非可替换元素</h2>
<p>大部分元素, 页面上显示的结果, 取决于元素内容, 称为<strong>非可替换元素</strong></p>
<p>少部分元素, 页面上显示的结果, 取决于元素属性, 称为<strong>可替换元素</strong></p>
<p>可替换元素: img、video、audio</p>
<p>绝大部分可替换元素均为行盒</p>
<p>可替换元素类似于行块盒, 盒模型中所有尺寸都有效</p>
<h1 id="常规流">常规流</h1>
<p>盒模型: 规定单个盒子的规则</p>
<p>视觉格式化模型(布局规则): 页面中的多个盒子排列规则</p>
<p>视觉格式化模型, 大体上将页面中盒子的排列分为三种方式:</p>
<ol>
<li>常规流</li>
<li>浮动</li>
<li>定位</li>
</ol>
<h2 id="常规流布局">常规流布局</h2>
<p>常规流、文档流、普通文档流、常规文档流</p>
<p>所有元素, 默认情况下, 都属于常规流布局</p>
<p>总体规则: 块盒独占一行, 行盒水平方向依次排列</p>
<p>包含块(containing block): 每个盒子都有它的包含块, 包含块决定了盒子的排列区域</p>
<p>绝大部分情况下, 盒子的包含块, 为其父元素的内容盒 content-box</p>
<p><strong>块盒</strong></p>
<ol>
<li>每个块盒的总宽度(margin + border + padding + content), 必须刚好等于包含块的宽度, 必须占满</li>
</ol>
<p>width的默认值是auto</p>
<p>margin的取值也可以是auto, 默认值是0</p>
<p>auto: 将剩余空间吸收掉</p>
<p>width吸收能力强于margin</p>
<p>若width、padding、border、margin计算后, 仍然有剩余空间, 该剩余空间被margin-right全部吸收</p>
<p>常规流中, 块盒在其包含块中 居中, 可以定宽, 然后左右margin设置为auto</p>
<p>以上是只看水平方向</p>
<ol start="2">
<li>每个块盒垂直方向上的auto值</li>
</ol>
<p>height: auto, 适应内容的高度, 默认值</p>
<p>margin: auto, 表示0</p>
<ol start="3">
<li>百分比取值</li>
</ol>
<p>padding、width、margin可以取值为百分比
四个方向上的 padding、margin 都是以宽算百分比</p>
<p>以上所有的百分比相对于包含块的宽度(只看width), 不区分box-sizing是内容盒还是边框盒</p>
<p>高度的百分比</p>
<blockquote>
<ol>
<li>包含块的高度是否取决于子元素的高度, 设置百分比无效</li>
<li>包含块的高度不取决于子元素的高度, 百分比相对于父元素的高度</li>
</ol>
</blockquote>
<p>高度补充: 第1个说的是父元素高度没设置, 也就是height: auto;由子元素的高度来撑开, 这时子元素如果是百分比高度, 则百分比无效
第2个说的是父元素设置了高度, 这时子元素如果是百分比高度, 则相对于父元素高度</p>
<ol start="4">
<li>上下外边距的合并</li>
</ol>
<p>两个常规流块盒, 上下边距相邻, 会进行合并</p>
<p>两个外边距取最大值</p>
<p>兄弟、父子元素都会出现
如果中间有东西把两个隔开, 就不会合并, 比如给border, 或者转换思路, 用padding(没有合并规则)</p>
<p>BFC也可以阻止合并</p>
<h1 id="浮动">浮动</h1>
<p>视觉格式化模型, 大体上将页面中盒子的排列分为三种方式:</p>
<ol>
<li>常规流</li>
<li>浮动 float</li>
<li>定位</li>
</ol>
<h2 id="应用场景">应用场景</h2>
<ol>
<li>文字环绕</li>
<li>横向排列</li>
</ol>
<h2 id="浮动的基本特点">浮动的基本特点</h2>
<p>修改float属性值为:</p>
<ul>
<li>left: 左浮动, 元素靠上靠左</li>
<li>right: 右浮动, 元素靠上靠右</li>
</ul>
<p>默认值为none</p>
<ol>
<li>当一个元素浮动后, 元素必定为块盒(更改display为block)</li>
<li>浮动元素的包含块, 和常规流一样, 为父元素的内容盒(content-box)</li>
</ol>
<h2 id="盒子尺寸">盒子尺寸</h2>
<ol>
<li>width为auto时, 适应内容宽度</li>
<li>height为auto时, 与常规流一致, 适应内容的高度</li>
<li>margin为auto, 为0</li>
<li>border、padding、百分比 设置与常规流一样</li>
</ol>
<h2 id="盒子排列">盒子排列</h2>
<ol>
<li>左浮动的盒子靠上靠左排列</li>
<li>右浮动的盒子靠上靠右排列</li>
<li>浮动盒子在包含块中排列时, 会避开常规流块盒</li>
<li>常规流块盒在排列时, 无视浮动盒子</li>
<li>行盒在排列时, 会避开浮动盒子</li>
</ol>
<blockquote>
<p>如果文字没有在行盒中, 浏览器会自动生成一个行盒包裹文字, 该行盒叫匿名行盒</p>
</blockquote>
<h2 id="高度坍塌">高度坍塌</h2>
<p>高度坍塌的根源: 常规流盒子的自动高度, 在计算时, 不会考虑浮动盒子</p>
<p>清除浮动, 涉及css属性: clear</p>
<ul>
<li>默认值: none</li>
<li>left: 清除左浮动, 该元素必须出现在前面所有左浮动盒子的下方</li>
<li>right: 清除右浮动, 该元素必须出现在前面所有右浮动盒子的下方</li>
<li>both: 清除左右浮动, 该元素必须出现在前面所有浮动盒子的下方</li>
</ul>
<h1 id="定位">定位</h1>
<p>视觉格式化模型, 大体上将页面中盒子的排列分为三种方式:</p>
<ol>
<li>常规流</li>
<li>浮动</li>
<li>定位 position</li>
</ol>
<p>定位: 手动控制元素在包含块中的精准位置</p>
<p>涉及的css属性: position</p>
<h2 id="position属性">position属性</h2>
<ul>
<li>默认值: static, 静态定位(不定位)</li>
<li>relative: 相对定位</li>
<li>absolute: 绝对定位</li>
<li>fixed: 固定定位</li>
</ul>
<p>一个元素, 只要position的取值不是static(默认值), 认为该元素是一个定位元素</p>
<p>定位元素会脱离文档流(相对定位除外)</p>
<p>一个脱离了文档流的元素:</p>
<ol>
<li>文档流中的元素摆放时, 会忽略脱离了文档流的元素</li>
<li>文档流中元素计算自动高度时, 会忽略脱离了文档流的元素</li>
</ol>
<h2 id="相对定位">相对定位</h2>
<p>不会导致元素脱离文档流, 只是让元素在原来位置上进行偏移</p>
<p>盒子的偏移不会对其他盒子造成任何影响
只是视觉上给人造成了偏差, 实际上盒子原来在哪, 现在还在哪(可以这样理解)</p>
<p>可以通过四个css属性设置其位置:</p>
<ul>
<li>left</li>
<li>right</li>
<li>top</li>
<li>bottom</li>
</ul>
<p>只有定位元素设置这些才有效</p>
<h2 id="绝对定位">绝对定位</h2>
<ol>
<li>宽/高为auto, 适应内容</li>
<li>包含块变化: 找祖先中第一个定位元素, 该元素的填充盒为其包含块。
若找不到, 则它的包含块为整个网页（初始包含块）</li>
</ol>
<h2 id="固定定位">固定定位</h2>
<p>其他情况和绝对定位完全一样</p>
<p>包含块不同: 固定为视口(浏览器的可视窗口)</p>
<h2 id="定位下的居中">定位下的居中</h2>
<ol>
<li>定宽（高）</li>
<li>将左右（上下）距离设置为0</li>
<li>将左右（上下）margin设置为auto</li>
</ol>
<p>绝对定位和固定定位中, margin为auto时, 会自动吸收剩余空间</p>
<h2 id="多个定位元素重叠时">多个定位元素重叠时</h2>
<p>堆叠上下文</p>
<p>设置z-index, 通常情况下, 该值越大, 越靠近用户</p>
<p>只有定位元素设置z-index有效</p>
<p>z-index可以是负数, 如果是负数, 则遇到常规流、浮动元素, 则会被其覆盖</p>
<h2 id="补充">补充</h2>
<ul>
<li>绝对定位、固定定位元素一定是块盒</li>
<li>绝对定位、固定定位元素一定不是浮动</li>
<li>没有外边距合并</li>
</ul>
<h1 id="更多的选择器">更多的选择器</h1>
<h2 id="更多伪类选择器">更多伪类选择器</h2>
<ol>
<li>first-child</li>
</ol>
<p>选择第一个子元素</p>
<p>first-of-type, 选中子元素中第一个指定类型的元素</p>
<ol start="2">
<li>last-child</li>
</ol>
<p>last-of-type</p>
<ol start="3">
<li>nth-child</li>
</ol>
<p>选中指定的第几个子元素</p>
<p>even: 关键字, 等同于2n
odd: 关键字, 等同于2n+1</p>
<ol start="4">
<li>nth-of-type</li>
</ol>
<p>选中指定的子元素中第几个某类型的元素</p>
<h2 id="更多的伪元素选择器">更多的伪元素选择器</h2>
<ol>
<li>first-letter</li>
</ol>
<p>选中元素中的第一个字母(中文就是第一个汉字)</p>
<ol start="2">
<li>first-line</li>
</ol>
<p>选中元素中的第一行的文字(始终选择, 不管怎么变)</p>
<ol start="3">
<li>selection</li>
</ol>
<p>选中被用户框选的文字</p>
<h1 id="更多的样式">更多的样式</h1>
<h2 id="不透明度">不透明度</h2>
<ol>
<li>opacity, 它设置的是整个元素的不透明(包括里面的内容和子元素等所有东西都会变), 它的取值是0~1, 0是没有 1是有</li>
<li>在颜色位置设置alpha通道(rgba() 背景色 边框色 字体颜色等)</li>
</ol>
<h2 id="鼠标">鼠标</h2>
<p>使用cursor设置</p>
<p>自定义图标 cursor: url(&#39;xxx.icon&#39;), auto; auto表示当浏览器不支持自定义图标时, 使用默认</p>
<h2 id="盒子隐藏">盒子隐藏</h2>
<ol>
<li>display: none; 不生成盒子</li>
<li>visibility: hidden; 生成盒子, 只是从视觉上移除盒子, 盒子仍占据空间</li>
</ol>
<h2 id="背景图">背景图</h2>
<p>img元素是属于HTML的概念</p>
<p>背景图属于css的概念</p>
<ol>
<li>当图片属于网页内容时, 必须使用img元素</li>
<li>当图片仅用于美化页面时, 必须使用背景图</li>
</ol>
<h3 id="涉及的css属性">涉及的css属性</h3>
<ol>
<li>background-image</li>
</ol>
<p>background-image: url(&#39;&#39;)</p>
<ol start="2">
<li>background-repeat</li>
</ol>
<p>background-repeat: no-repeat/repeat-x/repeat-y/repeat 默认</p>
<p>默认情况下, 背景图会在X Y中进行重复</p>
<ol start="3">
<li>background-size</li>
</ol>
<p>background-size: auto auto; 默认</p>
<p>预设值: container、cover, 类似于 object-fit</p>
<p>数值 百分比</p>
<ol start="4">
<li>background-position</li>
</ol>
<p>设置背景图的位置</p>
<p>预设值: left、bottom、right、top、center</p>
<p>数值 百分比</p>
<p>雪碧图(精灵图), 一般用px来控制</p>
<ol start="5">
<li>background-attachment</li>
</ol>
<p>通常用它控制背景图是否固定</p>
<ol start="6">
<li>背景图和背景颜色混用</li>
</ol>
</div>
</body>

</html>