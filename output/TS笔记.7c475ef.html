<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <!-- 文档标题-->
  <title>TS笔记</title>
  <meta name="keywords" content="">
  <meta name="description" content="">
  <!-- theme1用引号包着也能被正确替换 -->
  <link rel="stylesheet" href="../html-component/theme1.css">
</head>

<body>
  <style>
    body {
      padding: 0 10px;
    }
  </style>
  <!-- 插入主题样式 -->
  <!-- <style>
    theme1
  </style> -->
  <!-- 插入marked转换后的html -->
  <div class="markdown-body"><h1 id="ts中如何书写模块化语句">TS中如何书写模块化语句</h1>
<p>TS中, 导入和导出模块, 统一使用ES6的模块化标准</p>
<p>推荐使用具名导出, 编辑器会有智能提示, 而不用手写导入语句</p>
<p>导入时, 不要去加后缀名.ts, 因为编译后没有.ts文件</p>
<h1 id="编译结果中的模块化">编译结果中的模块化</h1>
<blockquote>
<p>前端领域中的模块化标准: ES6、commonjs、amd、umd</p>
</blockquote>
<p>可配置, 在tsconfig.json文件, 主要是compilerOptions</p>
<p>TS中的模块化在编译结果中:</p>
<ul>
<li>如果编译结果的模块化标准是ES6: 没有区别</li>
<li>如果编译结果的模块化标准是commonjs: 具名的导出会变成 exports 的属性, 默认的导出会变成 exports 的 default 属性; 导入还是命名空间形式的用法 xxx.yyy, 默认导入是 xxx.default</li>
</ul>
<blockquote>
<p>commonjs其实没有默认导出这个东西, 曲线救国, 加了 default 属性</p>
</blockquote>
<h4 id="可能遇到的问题-默认导入报错">可能遇到的问题: 默认导入报错</h4>
<pre><code class="language-typescript">// main.ts
import fs from &#39;fs&#39; // 报错, fs没有默认导出
fs.readFileSync(&#39;./&#39;)
</code></pre>
<h4 id="编译结果">编译结果</h4>
<pre><code class="language-javascript">// main.js
const fs_1 = require(&quot;fs&quot;);
fs_1.default.readFileSync(&#39;./&#39;); // 这明显有问题
</code></pre>
<p>原因: 编译结果的模块化标准是commonjs, 而 fs 的源码是 module.exports = {} 的语法, 非 exports.default, 编译结果中的 fs_1.default 就不对</p>
<h4 id="怎么解决">怎么解决</h4>
<pre><code class="language-typescript">// 方案一, 具名导入
// main.ts
import { readFileSync } from &#39;fs&#39;
readFileSync(&#39;./&#39;)
</code></pre>
<pre><code class="language-typescript">// 方案二, 把所有导出统一重命名再导入
// main.ts
import * as fs from &#39;fs&#39;
fs.readFileSync(&#39;./&#39;)
</code></pre>
<pre><code class="language-json">// 方案三, 改配置
// tsconfig.json
&quot;esModuleInterop&quot;: true,
// 也就是编译后, 增加一个辅助函数, 给加一个 default 属性, 配合默认导入
</code></pre>
<h1 id="如何在ts中书写commonjs模块化代码">如何在TS中书写commonjs模块化代码</h1>
<pre><code class="language-typescript">// child.ts
module.exports = {
  name: &#39;child&#39;,
  fn() {
    console.log(&#39;执行fn&#39;)
    return &#39;fn&#39;
  }
}
</code></pre>
<pre><code class="language-typescript">// main.ts
const c = require(&#39;./children/child&#39;)
</code></pre>
<p>上面两个代码写法, 编译结果和编译前代码一模一样, 但是ts中不推荐这样写法, 会丢失类型检查</p>
<p>一定要写的话, 得这样改语法</p>
<pre><code class="language-typescript">// child.ts
export = {
  name: &#39;child&#39;,
  fn() {
    console.log(&#39;执行fn&#39;)
    return &#39;fn&#39;
  }
}
</code></pre>
<pre><code class="language-typescript">// main.ts
import c = require(&#39;./children/child&#39;)
// import c from &quot;./children/child&quot;; 得搭配上面改的配置, 否则报错
</code></pre>
<p>编译结果是常见的commonjs的语法, 也获得了类型检查</p>
<h4 id="在ts中书写commonjs模块化代码">在TS中书写commonjs模块化代码</h4>
<p>导出: export = xxx</p>
<p>导入: import xxx = require(&#39;url&#39;)</p>
<h4 id="总之一句话-推荐es模块语法-毕竟是官方标准">总之一句话, 推荐ES模块语法, 毕竟是官方标准</h4>
<h1 id="模块解析">模块解析</h1>
<p>模块解析: 应该从什么位置寻找模块</p>
<p>TS中, 有两种模块解析策略</p>
<ul>
<li><p>classic: 经典</p>
</li>
<li><p>node: node解析策略 (唯一的变化, 是将js替换为ts)</p>
<ul>
<li>相对路径</li>
<li>非相对模块</li>
</ul>
</li>
</ul>
<p>建议项目中直接锁死为node解析, &quot;moduleResolution&quot;: &quot;node&quot;,</p>
<h1 id="tsconfigjson-配置项说明">tsconfig.json 配置项说明</h1>
<p><strong>compilerOptions</strong></p>
<table>
<thead>
<tr>
<th>子属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>target</td>
<td>编译后的js版本, 如ES3、ES5等</td>
</tr>
<tr>
<td>module</td>
<td>使用什么模块化标准来编译生成js</td>
</tr>
<tr>
<td>outDir</td>
<td>编译后的文件目录</td>
</tr>
<tr>
<td>removeComments</td>
<td>编译结果移除注释</td>
</tr>
<tr>
<td>noEmitOnError</td>
<td>错误时不生成编译结果</td>
</tr>
<tr>
<td>esModuleInterop</td>
<td>启用es模块化交互 非es模块导出</td>
</tr>
<tr>
<td>moduleResolution</td>
<td>设置解析模块的模式</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>同级属性</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>include</td>
<td>[&quot;./src/**/*&quot;]</td>
<td>表示编译src目录下的所有ts文件</td>
</tr>
<tr>
<td></td>
<td></td>
<td>**表示任意目录</td>
</tr>
<tr>
<td></td>
<td></td>
<td>*表示任意文件</td>
</tr>
<tr>
<td>exclude</td>
<td>默认值 [&quot;node_modules&quot;,</td>
<td>不需要被编译的文件目录</td>
</tr>
<tr>
<td></td>
<td>&quot;bower_componets&quot;,</td>
<td></td>
</tr>
<tr>
<td></td>
<td>&quot;jspm_packages&quot;]</td>
<td></td>
</tr>
<tr>
<td>extends</td>
<td>&quot;./tsconfig.base.json&quot;</td>
<td>引入其他配置文件，继承配置</td>
</tr>
<tr>
<td>files</td>
<td>[单个ts文件]</td>
<td>指定被编译的文件列表</td>
</tr>
</tbody></table>
</div>
</body>

</html>